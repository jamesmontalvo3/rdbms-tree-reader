<?phpclass TreeReader {	protected $data;	protected $select_cols;		public function __construct ($host, $user, $pass, $table, $id_col, $pid_col, $name_col, $select_cols) {				try {			// Persist Security Info=True;			$DBH = new PDO($host, $user, $pass);			// $DBH->setAttribute( PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT );			// $DBH->setAttribute( PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING );			// $DBH->setAttribute( \PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION );			$DBH->setAttribute( \PDO::ATTR_EMULATE_PREPARES, false );		}		catch(PDOException $e) {			echo $e->getMessage();		}		$this->items_table = $table;		$this->id_col = $id_col;		$this->pid_col = $pid_col;		$this->name_col = $name_col;		$this->setSelectColumns($select_cols);				$this->db = $DBH;	}		public function getSelectColumns () {		return $this->select_cols;	}	public function setSelectColumns ($cols) {		$table = $this->items_table;		if( is_array($cols) )			$this->select_cols =  $table . '.' . implode(", $table.", $cols);		else // assume string			$this->select_cols = "$table.$cols";		return $this;	}		static public function setup () {		return new self();	}	public function getData () {		return $this->data;	}		public function itemQuery ( $queryArgs ) {		$where = array();		$bind  = array();			foreach($queryArgs as $column => $value) {			$operation = substr($value, 0, 1); // first character of value			if ( ! in_array($operation, array('=','!','^','$','*')) )				$operation = '=';			else				$value = substr($value,1);			switch($operation) {								case '!': // match not column					$where[] = "$column != ? ";										break;				case '^': // match start of column					$where[] = "$column LIKE ? ";					$value = $value.'%';					break;				case '$': // match end of column					$where[] = "$column LIKE ? ";					$value = '%'.$value;					break;				case '*': // match anywhere in the column					$where[] = "$column LIKE ? ";					$value = '%'.$value.'%';					break;				default: // exact equality					$where[] = "$column = ? ";			}						$bind[] = $value;					}			if ( count($bind) == 0 )			return array(); // otherwise will return the whole tree, I think		else			$bind = array_merge($bind, $bind); // 					$where = implode(" AND ", $where);		$table = $this->items_table;		$id_col = $this->id_col;		$pid_col = $this->pid_col;		$select = $this->getSelectColumns();						$STH = $this->db->prepare( // (Id, ParentId)			"WITH ancestors (TreeIdColumn, TreeParentIdColumn)            AS (            -- anchor member declaration            SELECT $id_col, $pid_col FROM $table WHERE $where            UNION ALL             -- recursive member declaration            SELECT $table.$id_col, $table.$pid_col FROM $table            INNER JOIN ancestors ON ancestors.TreeParentIdColumn = $table.$id_col            ),             descendants (TreeIdColumn, TreeParentIdColumn)            AS (            -- anchor member declaration            SELECT $id_col, $pid_col FROM $table WHERE $where            UNION ALL             -- recursive member declaration            SELECT $table.$id_col, $table.$pid_col FROM $table            INNER JOIN descendants ON descendants.TreeIdColumn = $table.$pid_col            )            SELECT DISTINCT $select FROM $table RIGHT JOIN ancestors ON ancestors.TreeIdColumn = $table.$id_col            UNION            SELECT DISTINCT $select FROM $table RIGHT JOIN descendants ON descendants.TreeIdColumn = $table.$id_col"		);		$STH->execute($bind);		$STH->setFetchMode(\PDO::FETCH_ASSOC);		$this->data = $STH->fetchAll();		// echo "<pre>{$STH->queryString}<br /><br />";		// $STH->debugDumpParams();		// echo "</pre><br /><br /><br />";		return $this;				/*				*/	}		public function toResponseFormat ( $request ) {				switch( $request->params('format') ) {			case 'json-pretty':				$out = $this->toJSON( true, $request->params('callback') );				break;			case 'xml':				die('XML format not yet supported');				break;			case 'html':				// die('HTML format not yet supported');				$out = $this->toHTML();				break;			default: // json				$out = $this->toJSON( false, $request->params('callback') );		}		return $out;			}		/**	 *	Options:	 *		pretty, callback	 **/	public function toJSON ($pretty, $callback) {				if ($pretty) {			$out = json_encode(				$this->getData(), 				JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE			);		}		else {			$out = json_encode( $this->getData(), JSON_UNESCAPED_UNICODE );		}			if ( $callback ) {			$out = "$callback($out);";		}			if ($pretty) {			$out = "<pre>$out</pre>";		}				return $out;	}		public function toHTML () {		return $this->createUL( $this->getData() );	}		protected function createUL ($items) {				$out = '<ul>';		foreach($items as $c) {			$out .= '<li>' . $this->getHtmlLiContents($c);			if ( count($c['children']) > 0 )				$out .= $this->createUL($c['children']);			$out .= '</li>';		}		$out .= '</ul>';				return $out;	}	public function structure ( $type ) {		switch ($type) {			case 'details':				$x = 1; 				// this will compress the data into just				// details about the important items				break;			default:				$this->treeify();		}				return $this;	}		public function treeify () {				$raw  = $this->getData();		$flat = array();		$tree = array();		$id_col = $this->id_col;		$pid_col = $this->pid_col;				foreach ($raw as $index => $item) {			$id = $item[$id_col];			$pid = $item[$pid_col];						$flat[$id] = $item;			$flat[$id]['children'] = array();						}				foreach ($raw as $index => $item) {			$id = $item[$id_col];			$pid = $item[$pid_col];						if ($pid !== null) {				$flat[$pid]['children'][$id] =& $flat[$id];			} else {				$tree[$id] =& $flat[$id];			}		}		$this->data = $tree;				return $this;			}		protected function getHtmlLiContents ( $item ) {				return $item[ $this->$name_col ];			}	}